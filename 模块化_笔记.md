#                                                     JS模块化
## 一、模块化的理解

### 1、什么是模块?

* 将一个复杂的程序依据一定的规则(规范)**拆分**成几个块(文件), 并进行**组合**在一起
* 块的内部数据/实现是私有的, **只是向外部暴露一些接口(方法)与外部其它模块通信**

### 2、为什么要模块化？

（1）降低复杂度，提高解耦性

（2）避免命名冲突

（3）更好的分离，按需加载

（4）更高复用性，高可维护性

### 3、模块化概念带来的问题

（1）请求过多

（2）依赖模糊

（3）难以维护

## 二、模块化规范

前言:一个大的项目必定会使用模块化技术，使用模块化就会使用相应的模块化
规范，现在比较流行的模块化规范有以下2种:CommonJS、ES6

### 1、CommonJS（双端运行，可在浏览器和服务器执行）

#### 1.1 规范

1、官网：http://wiki.commonjs.org/wiki/Modulese
2、每个文件都是一个模块。
3、CommonJS模块化的代码既可在服务端运行，也可在浏览器端运行
4、服务器端:模块化的代码可直接运行。
5、浏览器端:模块化的代码要经过**Browserify**(http://browserify.org)编译。

```powershell
下载browserify
  * 全局: npm install browserify -g
  * 局部: npm install browserify --save-dev
打包处理：browserify ./app.js -o ./bundle.js
```

#### 1.2 基本语法

暴露语法

- 第一种：module.exports=value
- 第二种：exports.xxx=value

引入语法

- 引入第三方模块：require(xxx)  ,xxx为模块名
- 引入自定义模块：require(xxx),xxx为模块文件路径
- **若是暴露一个对象，可用解构赋值形式引入**

内置关系

![image-20240106141231882](D:\typora_photo\image-20240106141231882.png)

**暴露的本质是module.exports的内容，module.exports与exports不能混用，若混用了，以module.exports为准**

实例使用：

​                                ![image-20240106142232867](D:\typora_photo\image-20240106142232867.png)![image-20240106142303039](D:\typora_photo\image-20240106142303039.png)

​              ![image-20240106142907311](D:\typora_photo\image-20240106142907311.png)![image-20240106142936020](D:\typora_photo\image-20240106142936020.png)

### 2、ES6（只能在浏览器端运行）

#### 2.1 规范

1、每个文件都是一个模块。
2、要借助 Babel和Browserify依次编译代码，才能在浏览器端运行。
3、Babel中文网： https://www.babeljs.cn/

注意：babel：将ES6 ==>  ES5     jsx===> js

#### 2.2 准备依赖

```powershell
（1）全局安装:babel-cli、Browserify，执行命令如下:
     babel-cli只能将es6转化成cjs模块化，并不能真正转为es5
     npm install babe1-cli browserify -g
（2）局部安装:babel-preset-es2015
     npm install babe1-preset-es2015
（3）定义.babelrc文件
     {
      "presets": ["es2015"]
     }
     
 cli:command line interface
```

#### 2.2 基本语法

暴露模块:
1、分别暴露: export暴露内容，引入方式中{}并不是叫做解构赋值

![v](D:\typora_photo\image-20240106145217304.png)![image-20240106150841756](D:\typora_photo\image-20240106150841756.png)

![image-20240106152012601](D:\typora_photo\image-20240106152012601.png)

2、统一暴露: export{暴露内容1，暴露内容 2}

![image-20240106152409007](D:\typora_photo\image-20240106152543146.png)![image-20240106152646520](D:\typora_photo\image-20240106152646520.png)

3、默认暴露: export defalut暴露内容:

![image-20240106152802519](D:\typora_photo\image-20240106152802519.png)![image-20240106152829385](D:\typora_photo\image-20240106152829385.png)

## 三、说明

* 一个模块的组成

  * 数据--->内部的属性
  * 操作数据的行为--->内部的函数

* 模块化
  * 编码时是按照模块一个一个编码的, 整个项目就是一个模块化的项目

* 模块化的进化过程
  * 全局function模式 : 
    * 编码: 全局变量/函数
    * 问题: 污染全局命名空间, 容易引起命名冲突/数据不安全
  * namespace模式 : 
    * 编码: 将数据/行为封装到对象中
    * 解决: 命名冲突(减少了全局变量)
    * 问题: 数据不安全(外部可以直接修改模块内部的数据)
  * IIFE模式/增强
    * IIFE : 立即调用函数表达式--->匿名函数自调用
    * 编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口
    * 引入依赖: 通过函数形参来引入依赖模块
      ```
      (function(window, module2){
        var data = 'atguigu.com'
        function foo() {
           module2.xxx()
           console.log('foo()'+data)
        }
        function bar() {
           console.log('bar()'+data)
        }
        
        window.module = {foo}
      })(window, module2)
      ```

* 模块化规范
  * CommonJS
    * Node.js : 服务器端
    * Browserify : 浏览器端    也称为js的打包工具
    * 基本语法:
      * 定义暴露模块 : exports
        ```
        exports.xxx = value
        module.exports = value
        ```
        引入模块 : require
        ```
        var module = require('模块名/模块相对路径')
        ```
    * 引入模块发生在什么时候?
      * Node : 运行时, 动态同步引入
      * Browserify : 在运行前对模块进行编译/转译/打包的处理(已经将依赖的模块包含进来了), 
                  运行的是打包生成的js, 运行时不存在需要再从远程引入依赖模块
  * AMD : 浏览器端
    * require.js
    * 基本语法
      * 定义暴露模块: define([依赖模块名], function(){return 模块对象})
      * 引入模块: require(['模块1', '模块2', '模块3'], function(m1, m2){//使用模块对象})
      * 配置: 
        ```
        require.config({
          //基本路径
          baseUrl : 'js/',
          //标识名称与路径的映射
          paths : {
            '模块1' : 'modules/模块1',
            '模块2' : 'modules/模块2',
            'angular' : 'libs/angular',
            'angular-messages' : 'libs/angular-messages'
          },
          //非AMD的模块
          shim : {
            'angular' : {
                exports : 'angular'
            },
            'angular-messages' : {
                exports : 'angular-messages',
                deps : ['angular']
            }
          }
        })
        ```
  * CMD : 浏览器端
    * sea.js
    * 基本语法
      * 定义暴露模块: 
        ```
        define(function(require, module, exports){
          通过require引入依赖模块
          通过module/exports来暴露模块
          exports.xxx = value
        })
        ```
      * 使用模块seajs.use(['模块1', '模块2'])
  * ES6
    * ES6内置了模块化的实现
    * 基本语法
      * 定义暴露模块 : export
        * 暴露一个对象: 
          ```
          export default 对象
          ```
        * 暴露多个: 
          ```
          export var xxx = value1
          export let yyy = value2
          
          var xxx = value1
          let yyy = value2
          export {xxx, yyy}
          ```
        
      * 引入使用模块 : import
        * default模块:
          ```
          import xxx  from '模块路径/模块名'
          ```
        * 其它模块
          ```
          import {xxx, yyy} from '模块路径/模块名'
          import * as module1 from '模块路径/模块名'
          ```
    * 问题: 所有浏览器还不能直接识别ES6模块化的语法  
    * 解决:
        * 使用Babel将ES6--->ES5(使用了CommonJS) ----浏览器还不能直接支行
        * 使用Browserify--->打包处理----浏览器可以运行
          
    
    