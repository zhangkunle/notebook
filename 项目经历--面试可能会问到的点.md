### 项目经历--面试可能会问到的点

#### 伙伴匹配系统

##### **在这个系统中使用的注解：**

RestController（Controller层注解）

RequestMapping（“/user”）映射URL路径

CRossOrigin(跨域请求，因为前后端端口不一致，所以使用跨域注解映射到前端的注解，写在Controller类上，表示允许该控制器接收跨域请求，同时还要写一个配置类，写一个允许跨域的路径)，如果你想全局开启跨域支持或自定义跨域配置，可以通过创建一个配置类来实现。这可以通过实现 `WebMvcConfigurer` 接口或使用 `WebMvcConfigurerAdapter` 类来完成。在该类中可以使用 `addCorsMappings()` 方法来配置跨域支持。

@Resource注解和@autowired注解，需要注意 `@Resource` 注解与 Spring 框架的 `@Autowired` 和 `@Resource` 注解是有区别的，虽然它们都可以用来注入对象或资源，但它们的实现方式和作用范围不同。`@Resource` 是 Java EE 标准中定义的注解，适用于标准 Java EE 应用程序；而 `@Autowired` 和 `@Resource` 是 Spring 框架中定义的注解，适用于 Spring 应用程序。

@GetMapping/@PostMapping/PUTMapping/DeleteMapping后面加URL（注意接口调试时先加RequestMapping里面的注解内容，再加类上的）

GET用于查，Post用于创建或者更改/提交表单，PUT用于使用客户端提供的数据更新指定URL位置的资源，DeleteMapping用于将删除指定的URI位置的资源

@Configuration注解是用于表示这个类包含了一个或多个@Bean注解的方法，这些方法将被用于定义应用程序的Bean。在Spring应用程序上下文启动时，它将扫描@Configuration注解的类，并将其内部@Bean注解的方法作为Bean定义加载到应用程序上下文中。

@Component是Spring框架中的一个注解，用于将一个类标记为Spring Bean，并将其注册到应用程序上下文中。使该类可以被自动检测和实例化为一个Spring Bean。在Spring应用程序启动时，Spring容器会扫描所有被@Component注解标记的类，并将其注册为Spring Bean。如果要在其他组件中使用这些Spring Bean，则可以使用@Autowired或@Resource等注解将它们注入到需要它们的组件中。

@Slf4j 用于开启输出日志

@Data  lombok注解，用于自动生成get和set方法，还有构造器等

@MapperScan注解需要指定一个或多个包路径作为参数，表示需要扫描哪些包下的Mapper接口。在应用程序启动时，MyBatis框架会扫描这些包下的所有Mapper接口，并将其注册到MapperRegistry中，从而使得这些接口可以被应用程序中的其他组件所使用。

@RestControllerAdvice是Spring框架中的一个注解，用于定义一个全局的异常处理类，可以对所有Controller中抛出的异常进行统一处理。当应用程序中发生异常时，Spring会自动将异常信息传递给@RestControllerAdvice注解所标注的类的相应方法进行处理，从而实现全局异常处理的功能。

@RestControllerAdvice注解通常需要结合@ExceptionHandler注解（@ExceptionHandler后面填写的参数是用来捕捉看发生什么异常用）来使用，@ExceptionHandler注解用于定义处理特定异常类型的方法，被定义的方法需要返回一个合适的响应体来告知客户端发生了什么错误。@RestControllerAdvice注解可以同时包含多个@ExceptionHandler方法，每个方法可以处理不同的异常类型。

使用@RestControllerAdvice注解可以有效地避免应用程序中的异常信息直接暴露给客户端，提高了系统的健壮性和安全性。此外，使用@RestControllerAdvice注解还可以提高代码的复用性，减少代码冗余。

##### **如何在Spring Boot中实现统一的异常处理？**

定义一个包，用于实现对异常的封装处理，定义了一个全局异常处理器和自定义异常类，全局异常处理器用于处理运行时异常和自定义异常，并且统一返回，使用了@RestControllerAdvice+@ExceptionHandler注解，配合使用，写了两个类用于捕获各自的异常，ExceptionHandler里面可以填写参数来指定具体要返回的异常

##### **如何在项目中进行数据的返回的？**

定义一个通用返回类，配合异常处理器使用，在其中定义错误码，具体错误信息，错误信息描述等内容，再分别定义一个类的多个方法来返回不同情况的信息，实现统一封装，避免暴露给客户端信息

##### 什么是编辑距离算法，能介绍一下吗，动态规划的核心思想是什么能说一下吗

编辑距离算法（Edit Distance），也称Levenshtein距离，用于衡量两个字符串之间的差异程度。它是指由一个字符串转换成另一个字符串所需的最少操作次数，其中操作包括插入、删除、替换三种操作。

例如，将字符串“kitten”转换成字符串“sitting”，需要进行3次操作：

1. 将字符“k”替换为字符“s”
   2. 将字符“e”替换为字符“i”
      3. 插入字符“g”

因此，这两个字符串的编辑距离为3。

编辑距离算法的核心思想是动态规划。设字符串A和B的长度分别为m和n，定义一个二维数组dp[m+1][n+1]，其中dp[i][j]表示将A的前i个字符转换为B的前j个字符所需的最少操作次数。则有以下状态转移方程：

当A[i] == B[j]时，dp[i][j] = dp[i-1][j-1]；

否则，dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1；

其中，dp[i-1][j]表示删除A[i]，dp[i][j-1]表示插入B[j]，dp[i-1][j-1]表示替换A[i]为B[j]。

最终，dp[m][n]即为A和B的编辑距离

编辑距离算法的时间复杂度为O(m*n)，空间复杂度为O(m*n)。在实际应用中，可以通过优化空间复杂度来提高算法的效率。例如，可以使用滚动数组或矩阵转置等技巧来优化空间复杂度。



（动态规划）

\1. 定义状态：找到问题的最优子结构，明确问题中需要求解的状态。

\2. 设计转移方程：找到状态之间的递推关系，将原问题分解成若干个子问题。

\3. 初始化状态：找到问题中的边界条件，确定递推的起点。

\4. 求解最优解：按照递推关系，从起点开始递推，直到得到需要求解的状态。

##### 数据库表的设计

##### **你是如何确定数据库表结构的？你采用了哪些建表原则和规范？**

首先确定系统针对的用户，既然有创建伙伴和寻找伙伴的需求，就需要设计一个用户表，想要实现搜索，就还需要给每个用户上标签，上了标签之后需要标签表，同时因为用户和队伍是多对多的关系需要设计一个用户和队伍的关系表，这就是数据库的表结构。

**建表原则和规范**

\1. 主键和自增长：每张表都设置了一个主键，并使用了`auto_increment`实现自增长。

\2. 数据类型：对于每个字段都选择了合适的数据类型，如`varchar`、`int`、`datetime`等。

\3. 注释：每个表和字段都添加了注释，方便其他人阅读和理解。

#####  你对于表的设计是否考虑了数据冗余和范式设计的问题？如果考虑了，你是如何平衡冗余和范式的冲突的？（这里不知道我回答的对不对）

比如对于标签和用户之间的关系这个字段的设计，如果遵循第一范式的要求，那么在用户表的标签格中就不应该设计Json格式的字符串，但是考虑到如果新建一个标签表会变成多表联查，并且考虑到用户数据量很大所以没有存到多个表中，以提高查询效率和减少关联查询的次数。

##### **在数据量增长的情况下，你会如何考虑数据库的性能和扩展性？是否有考虑到分库分表的需求？**

\1. 确定数据库性能瓶颈并进行优化：可以使用各种数据库监控和性能调优工具，例如MySQL的slow query log，Explain等来发现慢查询、索引优化、缓存优化等问题，从而提高数据库性能。

\2. 垂直扩展：通过升级数据库服务器硬件（例如增加CPU，内存和磁盘容量等）来增加数据库的性能。但是，这种方法的成本较高，且在一定程度上受到硬件限制。

\3. 水平扩展：可以通过添加更多的数据库实例来扩展系统的容量。可以使用主从复制或分片技术来分摊负载，从而提高数据库的性能。

\4. 分库分表：在数据量增长到一定程度时，可以考虑使用分库分表来解决数据库性能和扩展性问题。可以将数据按照一定规则分成多个库或表，然后将它们分布在不同的服务器上。这种方法可以有效地提高数据库的扩展性和性能，但是也会带来一些额外的复杂性和成本。

##### ** 请介绍一下Redis分布式Session的实现方式**

因为Session只在同一个服务器上储存，Redis分布式Session，是通过将Session信息存储到Redis中实现的Session共享方案，让其他服务器也能拥有Session信息，它可以有效解决分布式系统中Session共享的问题。

##### **请举例说明一下如何使用Java8中的Stream流API处理复杂集合内容？**

比如有一个List<User> userList，想让他过滤出所有年龄小于30岁的用户，再按着id升序排列，最后返回id列表

可以先使用Stream流的filter过滤出年龄小于30的用链式调用在后面跟上排序，最后映射为map，再使用collect转换为List

##### Redis缓存的使用是为了解决高并发访问下数据库读写压力过大的问题，提高系统的性能和响应速度。下面是使用Redis缓存的好处和需要注意的问题：

Redis缓存的使用是为了解决高并发访问下数据库读写压力过大的问题，提高系统的性能和响应速度。下面是使用Redis缓存的好处和需要注意的问题：

好处：

\1. 提高性能和响应速度：Redis缓存使用内存进行数据存储，读写速度非常快，能够大大减少数据库的读写次数，提高系统的性能和响应速度。

\2. 缓解数据库压力：Redis缓存可以将热点数据缓存到内存中，减少数据库的读写压力，防止出现数据库瓶颈。

\3. 减少网络传输开销：Redis缓存位于应用层和数据库之间，可以缓存需要频繁查询的数据，避免频繁地进行网络传输，减少网络传输开销。

需要注意的问题：

\1. 缓存数据一致性问题：使用Redis缓存需要注意缓存数据和数据库数据的一致性问题，缓存数据的更新需要与数据库数据同步更新，避免出现数据不一致的情况。

\2. 缓存雪崩问题：当缓存中的数据过期或失效时，如果大量请求同时访问数据库，会导致数据库压力剧增，进而引起系统崩溃。为了避免这种情况的发生，可以采用分布式锁、缓存预热等方式进行缓解。

\3. 缓存穿透问题：当访问一个不存在的数据时，会导致缓存和数据库都无法命中，进而导致频繁地进行数据库查询，引起数据库压力剧增。为了避免这种情况的发生，可以采用布隆过滤器、缓存空对象等方式进行缓解。

\4. 缓存击穿问题：当一个热点数据过期或失效时，大量请求同时访问该数据，会导致缓存和数据库都无法命中，进而引起数据库压力剧增。为了避免这种情况的发生，可以采用分布式锁、缓存预热等方式进行缓解。

##### ** 什么是缓存预热？它的作用是什么？请说明如何通过分布式锁实现缓存预热和操作互斥？**

缓存预热是在系统启动之前或者业务高峰期之前，预先将热点数据加载到缓存中，避免在实际使用时因为缓存未命中而需要从数据库中读取数据，从而提升系统的性能和响应速度。

缓存预热的作用是在系统实际使用前，先将热点数据预先加载到缓存中，减少了系统实际运行时的缓存命中率低、从数据库中读取数据的情况，从而提高系统的性能和响应速度。

通过分布式锁实现缓存预热和操作互斥可以确保在多个节点同时进行缓存预热或者操作时，只有一个节点能够执行缓存预热或者操作，避免了重复操作和数据的不一致。

**具体实现方式如下：**

\1. 定义一个全局唯一的key，表示需要加锁的资源，例如缓存预热操作对应的key为“cache_preheat_lock”。

\2. **使用Redis的SETNX命令（set if not exists）来获取锁，**如果返回值为1表示获取锁成功，否则表示锁已经被其他节点获取，需要等待。

\3. 执行缓存预热操作或者其他需要操作互斥的操作。

\4. 执行完成后，**使用Redis的DEL命令删除锁对应的key**，释放锁。

需要注意的是，为了防止锁的失效导致死锁，**需要给锁设置一个过期时间**，确保在锁失效之后，其他节点可以重新获取锁。**另外，为了避免误删其他节点的锁，可以在DEL命令执行前先通过GET命令获取锁的值，判断是否是当前节点持有的锁**，如果是才能执行DEL命令。